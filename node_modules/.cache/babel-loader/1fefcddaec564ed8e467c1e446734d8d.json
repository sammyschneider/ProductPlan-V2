{"ast":null,"code":"import { useRef, useState, useEffect, useMemo, useCallback } from 'react'; // This of course could've been more streamlined with internal state instead of\n// refs, but then host hooks / components could not opt out of renders.\n// This could've been exported to its own module, but the current build doesn't\n// seem to work with module imports and I had no more time to spend on this...\n\nfunction useResolvedElement(subscriber, refOrElement) {\n  var _ref; // The default ref has to be non-conditionally declared here whether or not\n  // it'll be used as that's how hooks work.\n  // @see https://reactjs.org/docs/hooks-rules.html#explanation\n\n\n  var ref = null; // Default ref\n\n  var refElement = useRef(null);\n  var callbackRefElement = useRef(null);\n  var refCallback = useCallback(function (element) {\n    callbackRefElement.current = element;\n    callSubscriber();\n  }, []);\n  var lastReportedElementRef = useRef(null);\n  var cleanupRef = useRef();\n\n  var callSubscriber = function callSubscriber() {\n    var element = null;\n\n    if (callbackRefElement.current) {\n      element = callbackRefElement.current;\n    } else if (refElement.current) {\n      element = refElement.current;\n    } else if (refOrElement instanceof HTMLElement) {\n      element = refOrElement;\n    }\n\n    if (lastReportedElementRef.current === element) {\n      return;\n    }\n\n    if (cleanupRef.current) {\n      cleanupRef.current(); // Making sure the cleanup is not called accidentally multiple times.\n\n      cleanupRef.current = null;\n    }\n\n    lastReportedElementRef.current = element; // Only calling the subscriber, if there's an actual element to report.\n\n    if (element) {\n      cleanupRef.current = subscriber(element);\n    }\n  };\n\n  if (refOrElement && !(refOrElement instanceof HTMLElement)) {\n    // Overriding the default ref with the given one\n    ref = refOrElement;\n  } // On each render, we check whether a ref changed, or if we got a new raw\n  // element.\n\n\n  useEffect(function () {\n    // Note that this does not mean that \"element\" will necessarily be whatever\n    // the ref currently holds. It'll simply \"update\" `element` each render to\n    // the current ref value, but there's no guarantee that the ref value will\n    // not change later without a render.\n    // This may or may not be a problem depending on the specific use case.\n    if (ref) {\n      refElement.current = ref.current;\n    }\n\n    callSubscriber();\n  }, [ref, (_ref = ref) == null ? void 0 : _ref.current, refOrElement]);\n  return refCallback;\n}\n\nfunction useResizeObserver(opts) {\n  if (opts === void 0) {\n    opts = {};\n  } // Saving the callback as a ref. With this, I don't need to put onResize in the\n  // effect dep array, and just passing in an anonymous function without memoising\n  // will not reinstantiate the hook's ResizeObserver\n\n\n  var onResize = opts.onResize;\n  var onResizeRef = useRef(undefined);\n  onResizeRef.current = onResize; // Using a single instance throughout the hook's lifetime\n\n  var resizeObserverRef = useRef();\n\n  var _useState = useState({\n    width: undefined,\n    height: undefined\n  }),\n      size = _useState[0],\n      setSize = _useState[1]; // In certain edge cases the RO might want to report a size change just after\n  // the component unmounted.\n\n\n  var didUnmount = useRef(false);\n  useEffect(function () {\n    return function () {\n      didUnmount.current = true;\n    };\n  }, []); // Using a ref to track the previous width / height to avoid unnecessary renders\n\n  var previous = useRef({\n    width: undefined,\n    height: undefined\n  }); // This block is kinda like a useEffect, only it's called whenever a new\n  // element could be resolved based on the ref option. It also has a cleanup\n  // function.\n\n  var refCallback = useResolvedElement(function (element) {\n    // Initialising the RO instance\n    if (!resizeObserverRef.current) {\n      // Saving a single instance, used by the hook from this point on.\n      resizeObserverRef.current = new ResizeObserver(function (entries) {\n        if (!Array.isArray(entries)) {\n          return;\n        } // Since we only observe the one element, we don't need to loop over the\n        // array\n\n\n        if (!entries.length) {\n          return;\n        }\n\n        var entry = entries[0]; // `Math.round` is in line with how CSS resolves sub-pixel values\n\n        var newWidth = Math.round(entry.contentRect.width);\n        var newHeight = Math.round(entry.contentRect.height);\n\n        if (previous.current.width !== newWidth || previous.current.height !== newHeight) {\n          var newSize = {\n            width: newWidth,\n            height: newHeight\n          };\n\n          if (onResizeRef.current) {\n            onResizeRef.current(newSize);\n          } else {\n            previous.current.width = newWidth;\n            previous.current.height = newHeight;\n\n            if (!didUnmount.current) {\n              setSize(newSize);\n            }\n          }\n        }\n      });\n    }\n\n    resizeObserverRef.current.observe(element);\n    return function () {\n      if (resizeObserverRef.current) {\n        resizeObserverRef.current.unobserve(element);\n      }\n    };\n  }, opts.ref);\n  return useMemo(function () {\n    return {\n      ref: refCallback,\n      width: size.width,\n      height: size.height\n    };\n  }, [refCallback, size ? size.width : null, size ? size.height : null]);\n}\n\nexport default useResizeObserver;","map":{"version":3,"sources":["/Users/SammySchneider/dev/noa/sammys-interview/productplan-candidate-hw/node_modules/use-resize-observer/dist/bundle.esm.js"],"names":["useRef","useState","useEffect","useMemo","useCallback","useResolvedElement","subscriber","refOrElement","_ref","ref","refElement","callbackRefElement","refCallback","element","current","callSubscriber","lastReportedElementRef","cleanupRef","HTMLElement","useResizeObserver","opts","onResize","onResizeRef","undefined","resizeObserverRef","_useState","width","height","size","setSize","didUnmount","previous","ResizeObserver","entries","Array","isArray","length","entry","newWidth","Math","round","contentRect","newHeight","newSize","observe","unobserve"],"mappings":"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","sourcesContent":["import { useRef, useState, useEffect, useMemo, useCallback } from 'react';\n\n// This of course could've been more streamlined with internal state instead of\n// refs, but then host hooks / components could not opt out of renders.\n// This could've been exported to its own module, but the current build doesn't\n// seem to work with module imports and I had no more time to spend on this...\nfunction useResolvedElement(subscriber, refOrElement) {\n  var _ref;\n\n  // The default ref has to be non-conditionally declared here whether or not\n  // it'll be used as that's how hooks work.\n  // @see https://reactjs.org/docs/hooks-rules.html#explanation\n  var ref = null; // Default ref\n\n  var refElement = useRef(null);\n  var callbackRefElement = useRef(null);\n  var refCallback = useCallback(function (element) {\n    callbackRefElement.current = element;\n    callSubscriber();\n  }, []);\n  var lastReportedElementRef = useRef(null);\n  var cleanupRef = useRef();\n\n  var callSubscriber = function callSubscriber() {\n    var element = null;\n\n    if (callbackRefElement.current) {\n      element = callbackRefElement.current;\n    } else if (refElement.current) {\n      element = refElement.current;\n    } else if (refOrElement instanceof HTMLElement) {\n      element = refOrElement;\n    }\n\n    if (lastReportedElementRef.current === element) {\n      return;\n    }\n\n    if (cleanupRef.current) {\n      cleanupRef.current(); // Making sure the cleanup is not called accidentally multiple times.\n\n      cleanupRef.current = null;\n    }\n\n    lastReportedElementRef.current = element; // Only calling the subscriber, if there's an actual element to report.\n\n    if (element) {\n      cleanupRef.current = subscriber(element);\n    }\n  };\n\n  if (refOrElement && !(refOrElement instanceof HTMLElement)) {\n    // Overriding the default ref with the given one\n    ref = refOrElement;\n  } // On each render, we check whether a ref changed, or if we got a new raw\n  // element.\n\n\n  useEffect(function () {\n    // Note that this does not mean that \"element\" will necessarily be whatever\n    // the ref currently holds. It'll simply \"update\" `element` each render to\n    // the current ref value, but there's no guarantee that the ref value will\n    // not change later without a render.\n    // This may or may not be a problem depending on the specific use case.\n    if (ref) {\n      refElement.current = ref.current;\n    }\n\n    callSubscriber();\n  }, [ref, (_ref = ref) == null ? void 0 : _ref.current, refOrElement]);\n  return refCallback;\n}\n\nfunction useResizeObserver(opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  // Saving the callback as a ref. With this, I don't need to put onResize in the\n  // effect dep array, and just passing in an anonymous function without memoising\n  // will not reinstantiate the hook's ResizeObserver\n  var onResize = opts.onResize;\n  var onResizeRef = useRef(undefined);\n  onResizeRef.current = onResize; // Using a single instance throughout the hook's lifetime\n\n  var resizeObserverRef = useRef();\n\n  var _useState = useState({\n    width: undefined,\n    height: undefined\n  }),\n      size = _useState[0],\n      setSize = _useState[1]; // In certain edge cases the RO might want to report a size change just after\n  // the component unmounted.\n\n\n  var didUnmount = useRef(false);\n  useEffect(function () {\n    return function () {\n      didUnmount.current = true;\n    };\n  }, []); // Using a ref to track the previous width / height to avoid unnecessary renders\n\n  var previous = useRef({\n    width: undefined,\n    height: undefined\n  }); // This block is kinda like a useEffect, only it's called whenever a new\n  // element could be resolved based on the ref option. It also has a cleanup\n  // function.\n\n  var refCallback = useResolvedElement(function (element) {\n    // Initialising the RO instance\n    if (!resizeObserverRef.current) {\n      // Saving a single instance, used by the hook from this point on.\n      resizeObserverRef.current = new ResizeObserver(function (entries) {\n        if (!Array.isArray(entries)) {\n          return;\n        } // Since we only observe the one element, we don't need to loop over the\n        // array\n\n\n        if (!entries.length) {\n          return;\n        }\n\n        var entry = entries[0]; // `Math.round` is in line with how CSS resolves sub-pixel values\n\n        var newWidth = Math.round(entry.contentRect.width);\n        var newHeight = Math.round(entry.contentRect.height);\n\n        if (previous.current.width !== newWidth || previous.current.height !== newHeight) {\n          var newSize = {\n            width: newWidth,\n            height: newHeight\n          };\n\n          if (onResizeRef.current) {\n            onResizeRef.current(newSize);\n          } else {\n            previous.current.width = newWidth;\n            previous.current.height = newHeight;\n\n            if (!didUnmount.current) {\n              setSize(newSize);\n            }\n          }\n        }\n      });\n    }\n\n    resizeObserverRef.current.observe(element);\n    return function () {\n      if (resizeObserverRef.current) {\n        resizeObserverRef.current.unobserve(element);\n      }\n    };\n  }, opts.ref);\n  return useMemo(function () {\n    return {\n      ref: refCallback,\n      width: size.width,\n      height: size.height\n    };\n  }, [refCallback, size ? size.width : null, size ? size.height : null]);\n}\n\nexport default useResizeObserver;\n"]},"metadata":{},"sourceType":"module"}