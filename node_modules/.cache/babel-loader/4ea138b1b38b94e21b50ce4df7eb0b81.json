{"ast":null,"code":"import { createBar, createLane, createRow } from \"./factories\";\nimport { shiftDateMillis } from \"./dateHelpers\";\n/*\n * This module performs the \"business logic\". Each action returns\n * a function that mutates some state, so the functions can be called\n * directly in tests, or used with immer to perform state updates in\n * RoadmapState. This allows the state mutations to be tested without\n * any component tree.\n */\n\nexport function addLane() {\n  return state => {\n    state.lanes.push(createLane());\n  };\n}\nexport function addBar(barToAdd, destination) {\n  return state => {\n    const {\n      laneId,\n      index,\n      start,\n      newRow\n    } = destination;\n    let bar = null;\n\n    if (barToAdd) {\n      bar = { ...barToAdd\n      };\n      const diff = start.getTime() - bar.start.getTime();\n      shiftDateMillis(bar.start, diff);\n      shiftDateMillis(bar.end, diff);\n    } else {\n      bar = createBar(start);\n    }\n\n    const {\n      lanes\n    } = state;\n    const targetLane = lanes.find(lane => lane.id === laneId);\n\n    if (!targetLane) {\n      return;\n    }\n\n    bar.location = {\n      laneId,\n      index\n    };\n\n    if (newRow) {\n      const row = createRow();\n      row.bars.push(bar);\n      targetLane.rows.splice(index, 0, row);\n    } else {\n      targetLane.rows[index].bars.push(bar);\n    }\n\n    fixBarLocations(targetLane);\n  };\n}\nexport function deleteBar(bar) {\n  return state => {\n    removeBar(bar)(state);\n    removeEmptyRows()(state);\n  };\n} // This function removes a bar, but doesn't remove empty rows.\n\nfunction removeBar(bar) {\n  return state => {\n    const {\n      laneId,\n      index\n    } = bar.location;\n    const {\n      lanes\n    } = state;\n    const lane = lanes.find(lane => lane.id === laneId);\n\n    if (!lane) {\n      return;\n    }\n\n    const row = lane.rows[index];\n    const barIndex = row.bars.findIndex(b => b.id === bar.id);\n    row.bars.splice(barIndex, 1);\n  };\n}\n\nexport function removeEmptyRows() {\n  return state => {\n    for (let lane of state.lanes) {\n      lane.rows = lane.rows.filter(r => r.bars.length > 0);\n      fixBarLocations(lane);\n    }\n  };\n}\nexport function moveBar(bar, destination) {\n  return s => {\n    removeBar(bar)(s);\n    addBar(bar, destination)(s);\n    removeEmptyRows()(s);\n  };\n}\n\nfunction fixBarLocations(lane) {\n  for (let i = 0; i < lane.rows.length; i++) {\n    for (let b of lane.rows[i].bars) {\n      b.location.index = i;\n    }\n  }\n}","map":{"version":3,"sources":["/Users/SammySchneider/dev/ProductPlan/src/roadmap.js"],"names":["createBar","createLane","createRow","shiftDateMillis","addLane","state","lanes","push","addBar","barToAdd","destination","laneId","index","start","newRow","bar","diff","getTime","end","targetLane","find","lane","id","location","row","bars","rows","splice","fixBarLocations","deleteBar","removeBar","removeEmptyRows","barIndex","findIndex","b","filter","r","length","moveBar","s","i"],"mappings":"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","sourcesContent":["import { createBar, createLane, createRow } from \"./factories\";\nimport { shiftDateMillis } from \"./dateHelpers\";\n\n/*\n * This module performs the \"business logic\". Each action returns\n * a function that mutates some state, so the functions can be called\n * directly in tests, or used with immer to perform state updates in\n * RoadmapState. This allows the state mutations to be tested without\n * any component tree.\n */\n\nexport function addLane() {\n  return state => {\n    state.lanes.push(createLane());\n  };\n}\n\nexport function addBar(barToAdd, destination) {\n  return state => {\n    const { laneId, index, start, newRow } = destination;\n    let bar = null;\n    if (barToAdd) {\n      bar = { ...barToAdd };\n      const diff = start.getTime() - bar.start.getTime();\n      shiftDateMillis(bar.start, diff);\n      shiftDateMillis(bar.end, diff);\n    } else {\n      bar = createBar(start);\n    }\n\n    const { lanes } = state;\n    const targetLane = lanes.find(lane => lane.id === laneId);\n    if (!targetLane) {\n      return;\n    }\n\n    bar.location = { laneId, index };\n    if (newRow) {\n      const row = createRow();\n      row.bars.push(bar);\n      targetLane.rows.splice(index, 0, row);\n    } else {\n      targetLane.rows[index].bars.push(bar);\n    }\n    fixBarLocations(targetLane);\n  };\n}\n\nexport function deleteBar(bar) {\n  return state => {\n    removeBar(bar)(state);\n    removeEmptyRows()(state);\n  };\n}\n\n// This function removes a bar, but doesn't remove empty rows.\nfunction removeBar(bar) {\n  return state => {\n    const { laneId, index } = bar.location;\n    const { lanes } = state;\n    const lane = lanes.find(lane => lane.id === laneId);\n    if (!lane) {\n      return;\n    }\n\n    const row = lane.rows[index];\n    const barIndex = row.bars.findIndex(b => b.id === bar.id);\n    row.bars.splice(barIndex, 1);\n  };\n}\n\nexport function removeEmptyRows() {\n  return state => {\n    for (let lane of state.lanes) {\n      lane.rows = lane.rows.filter(r => r.bars.length > 0);\n      fixBarLocations(lane);\n    }\n  };\n}\n\nexport function moveBar(bar, destination) {\n  return s => {\n    removeBar(bar)(s);\n    addBar(bar, destination)(s);\n    removeEmptyRows()(s);\n  };\n}\n\nfunction fixBarLocations(lane) {\n  for (let i = 0; i < lane.rows.length; i++) {\n    for (let b of lane.rows[i].bars) {\n      b.location.index = i;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}